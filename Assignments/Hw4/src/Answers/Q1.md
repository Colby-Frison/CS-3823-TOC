
# Question 1

**(i)**  
The grammar generates all strings with some number of leading `a`’s, followed by some number of `b`’s, and as many trailing `c`’s as the combined count of `a`’s and `b`’s. Formally,


$L(G) = \{ a^i b^j c^{i+j} \mid i, j \geq 0 \}$


- The rule $S \rightarrow a S c$ adds one $a$ to the front and a $c$ to the back for each use.
- The rule $S \rightarrow T$ passes control to $T$.
- The nonterminal $T$ generates $b^j c^j$ using repeated $T \rightarrow b T c$ and eventually $T \rightarrow \lambda$ (which also allows for the empty string case when both $i = 0$ and $j = 0$).

---

**(ii)**  
We convert the grammar G to a PDA that accepts by empty stack. Following the standard construction, the PDA is formally defined as:

**Formal Definition:**
$M = (Q, \Sigma, \Gamma, \delta, q_0, F)$

Where:
- **Q** = $\{ q_0, q, q_{acc} \}$ (finite set of states)
- **Σ** = $\{ a, b, c \}$ (input alphabet)
- **Γ** = $\{ a, b, c, S, T, \$ \}$ (stack alphabet, where $\$$ is the bottom-of-stack marker)
- **δ**: Transition function (defined below)
- **q₀** = $q_0$ (start state)
- **F** = $\{ q_{acc} \}$ (set of accept states)

**Note:** The stack starts empty, and we use $\$$ as a bottom-of-stack marker. The PDA accepts by empty stack: when the stack is reduced to just $\$$ and the input is fully consumed, we transition to the accept state.

## State-by-State Description

### State $q_0$ (Initialization State)
**Purpose:** Sets up the PDA by initializing the stack with the bottom marker $\$$ and placing the start symbol $S$ on the stack.

**Transitions from $q_0$:**
- $\lambda, \lambda \rightarrow \$ S$ (goes to state $q$)  
  - Reads: nothing (λ-move)  
  - Pops: nothing (stack is empty initially)  
  - Pushes: $\$ S$ (pushes $\$$ first as bottom marker, then $S$ on top)  
  - Goes to: state $q$

### State $q$ (Main Processing State)
**Purpose:** Performs all grammar expansions and terminal matching. This is where the PDA simulates the grammar derivations.

**Transitions from $q$:**

**Variable Expansion Transitions:**
1. $\lambda, S \rightarrow c S a$ (goes to state $q$)  
   - Reads: nothing (λ-move)  
   - Pops: $S$  
   - Pushes: $c S a$ (pushes $c$ first, then $S$, then $a$ on top)  
   - Corresponds to: production $S \rightarrow a S c$ (pushed in reverse order)

2. $\lambda, S \rightarrow T$ (goes to state $q$)  
   - Reads: nothing (λ-move)  
   - Pops: $S$  
   - Pushes: $T$  
   - Corresponds to: production $S \rightarrow T$

3. $\lambda, T \rightarrow c T b$ (goes to state $q$)  
   - Reads: nothing (λ-move)  
   - Pops: $T$  
   - Pushes: $c T b$ (pushes $c$ first, then $T$, then $b$ on top)  
   - Corresponds to: production $T \rightarrow b T c$ (pushed in reverse order)

4. $\lambda, T \rightarrow \lambda$ (goes to state $q$)  
   - Reads: nothing (λ-move)  
   - Pops: $T$  
   - Pushes: nothing (empty string)  
   - Corresponds to: production $T \rightarrow \lambda$

**Terminal Matching Transitions:**
5. $a, a \rightarrow \lambda$ (goes to state $q$)  
   - Reads: input symbol $a$  
   - Pops: stack symbol $a$  
   - Pushes: nothing  
   - Goes to: state $q$

6. $b, b \rightarrow \lambda$ (goes to state $q$)  
   - Reads: input symbol $b$  
   - Pops: stack symbol $b$  
   - Pushes: nothing  
   - Goes to: state $q$

7. $c, c \rightarrow \lambda$ (goes to state $q$)  
   - Reads: input symbol $c$  
   - Pops: stack symbol $c$  
   - Pushes: nothing  
   - Goes to: state $q$

**Acceptance Transition:**
8. $\lambda, \$ \rightarrow \lambda$ (goes to state $q_{acc}$)  
   - Reads: nothing (λ-move)  
   - Pops: $\$$ (the bottom-of-stack marker)  
   - Pushes: nothing  
   - Goes to: state $q_{acc}$  
   - **Condition:** This transition is only taken when the input has been fully consumed and the stack has been reduced to just $\$$

### State $q_{acc}$ (Accepting State)
**Purpose:** Final accepting state. Once reached, the PDA has successfully recognized the input string.

**Transitions from $q_{acc}$:**
- None (this is a terminal accepting state)

## How the PDA Works

The PDA operates as follows:

1. **Start:** Begin in state $q_0$ with an empty stack.

2. **Initialization:** Use the transition from $q_0$ to push $\$$ (bottom marker) and $S$ (start symbol) onto the stack, then move to state $q$.

3. **Processing Loop (in state $q$):**
   - **If the top of the stack is a nonterminal ($S$ or $T$):** Nondeterministically choose one of the expansion transitions to simulate a grammar production. The right-hand side of the production is pushed onto the stack in reverse order so that the leftmost terminal appears on top.
   - **If the top of the stack is a terminal ($a$, $b$, or $c$):** Match it with the next input symbol. If they match, consume the input symbol and pop the stack symbol. If they don't match, this computation path fails.
   - **If the stack is reduced to $\$$ and the input is fully consumed:** Use the acceptance transition to move to $q_{acc}$.

4. **Acceptance:** The PDA accepts by empty stack (when $\$$ is popped and we move to $q_{acc}$ with no input remaining).

The key insight is that pushing production right-hand sides in reverse order ensures that terminals appear on the stack in the same order they should appear in the input string, allowing the PDA to match them sequentially.


