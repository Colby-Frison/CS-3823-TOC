# Regular Grammars

## Table of Contents
- [Introduction to Regular Grammars](#introduction-to-regular-grammars)
- [Formal Definition](#formal-definition)
- [Right-Linear vs Left-Linear Grammars](#right-linear-vs-left-linear-grammars)
- [Equivalence with Finite Automata](#equivalence-with-finite-automata)
- [Relationship with Context-Free Grammars](#relationship-with-context-free-grammars)
- [Examples](#examples)

---

## Introduction to Regular Grammars

Regular grammars are the simplest type of formal grammar, generating exactly the **regular languages** (the same class recognized by finite automata). They are a proper subset of context-free grammars.

**Key characteristics:**
- Production rules are restricted in form
- Can only generate languages that finite automata can recognize
- Less powerful than context-free grammars but simpler to work with

**Applications:**
- Lexical analysis (token recognition)
- Simple pattern matching
- Regular expression implementation
- Text processing

---

## Formal Definition

A **regular grammar** is a context-free grammar where all production rules are either:

**Right-linear form:**
- $A \to xB$ where $A, B \in V$ (nonterminals) and $x \in T^*$ (string of terminals)
- $A \to x$ where $A \in V$ and $x \in T^*$

**Left-linear form:**
- $A \to Bx$ where $A, B \in V$ (nonterminals) and $x \in T^*$ (string of terminals)
- $A \to x$ where $A \in V$ and $x \in T^*$

**Important:** A grammar cannot mix right-linear and left-linear forms. It must be entirely one or the other.

---

## Right-Linear vs Left-Linear Grammars

### Right-Linear Grammars

All productions have the form:
- $A \to xB$ (nonterminal on the right)
- $A \to x$ (terminal string)

**Example:**
$$
\begin{array}{rcl}
S & \to & 0S \mid 1A \mid \varepsilon \\
A & \to & 0A \mid 1S
\end{array}
$$

This generates strings with an even number of 1's.

### Left-Linear Grammars

All productions have the form:
- $A \to Bx$ (nonterminal on the left)
- $A \to x$ (terminal string)

**Example:**
$$
\begin{array}{rcl}
S & \to & S0 \mid A1 \mid \varepsilon \\
A & \to & A0 \mid S1
\end{array}
$$

This also generates strings with an even number of 1's (but the grammar structure is different).

**Note:** Every right-linear grammar has an equivalent left-linear grammar and vice versa.

---

## Equivalence with Finite Automata

### Theorem
A language is regular **if and only if** it is generated by some regular grammar.

### Conversion: Regular Grammar → Finite Automaton

**For right-linear grammars:**
1. Create a state for each nonterminal
2. Add an accept state $q_{accept}$
3. For each production $A \to xB$: Add transition from state $A$ to state $B$ on input $x$
4. For each production $A \to x$: Add transition from state $A$ to $q_{accept}$ on input $x$
5. For each production $A \to \varepsilon$: Make state $A$ an accept state
6. Start state is the start symbol $S$

**For left-linear grammars:**

Its easier to just convert to right linear first and then convert to the finite automaton.

**Convert to right-linear first:**

1. Convert the left-linear grammar to an equivalent right-linear grammar
2. Then apply the right-linear conversion algorithm above

**Conversion process (left-linear → right-linear):**
- Reverse all productions: $A \to Bx$ becomes $A \to xB$
- Reverse the language (if $L$ is generated by left-linear grammar, then $L^R$ is generated by the converted right-linear grammar)
- Construct the automaton for the right-linear grammar
- Reverse the automaton to get one for the original language

### Conversion: Finite Automaton → Regular Grammar

1. Create a nonterminal for each state
2. Start symbol is the start state
3. For each transition $\delta(q, a) = r$: Add production $q \to ar$
4. For each accept state $q$: Add production $q \to \varepsilon$

---

## Relationship with Context-Free Grammars

**Hierarchy:**
```
Regular Grammars ⊂ Context-Free Grammars
```

**Key facts:**
- Every regular grammar is a context-free grammar (with restricted production forms)
- Not every context-free grammar is regular
- Regular languages $\subset$ Context-free languages

**Testing if a CFG is regular:**
- Check if all productions are right-linear or left-linear
- If yes, the grammar is regular and generates a regular language
- If no, the grammar may still generate a regular language, but the grammar itself is not regular

---

## Examples

### Example 1: Grammar for Strings with At Most Two 0's

**Problem:** Let $\Sigma = \{0, 1\}$. Find a regular grammar that generates the language:
$$L = \{w \in \Sigma^* \mid w \text{ has at most two } 0\text{'s}\}$$

**Solution:**

We construct a right-linear grammar by creating states that count the number of 0's seen so far:
- State $S$: 0 zeros seen (start symbol)
- State $A$: 1 zero seen
- State $B$: 2 zeros seen

From each state, we can:
- Read a 1 and stay in the current state
- Read a 0 and move to the next state (unless we're already at 2 zeros)
- Terminate (accept), since all states represent valid strings

**The regular grammar is:**
$$
\begin{array}{rcl}
S & \to & 1S \mid 0A \mid \varepsilon \\
A & \to & 1A \mid 0B \mid \varepsilon \\
B & \to & 1B \mid \varepsilon
\end{array}
$$

**Verification:**

This grammar generates all strings over $\{0,1\}$ with at most two 0's. For example:

- String "01011": 
  $$S \Rightarrow 0A \Rightarrow 01A \Rightarrow 010B \Rightarrow 0101B \Rightarrow 01011B \Rightarrow 01011$$
  (2 zeros, valid)

- String "000" cannot be generated: 
  $$S \Rightarrow 0A \Rightarrow 00B$$
  but $B$ has no rule for producing another 0, so the derivation cannot continue.

**Conversion to DFA:**

The equivalent DFA would have:
- States: $\{S, A, B, q_{reject}\}$
- Start state: $S$
- Accept states: $\{S, A, B\}$
- Transitions:
  - $\delta(S, 0) = A$, $\delta(S, 1) = S$
  - $\delta(A, 0) = B$, $\delta(A, 1) = A$
  - $\delta(B, 0) = q_{reject}$, $\delta(B, 1) = B$
  - $\delta(q_{reject}, 0) = q_{reject}$, $\delta(q_{reject}, 1) = q_{reject}$

---

### Example 2: Identifying Regular Grammars

**Problem:** Consider the grammar $G_2$:
$$
\begin{array}{rcl}
S & \to & 0X \\
X & \to & 0X \mid 1X \mid 1
\end{array}
$$

Is this a regular grammar? If so, what language does it generate?

**Solution:**

Let's examine the productions of $G_2$:
$$
\begin{array}{rcll}
S & \to & 0X & \text{(form: } A \to xB \text{, where } x=0, B=X \text{)} \\
X & \to & 0X & \text{(form: } A \to xB \text{, where } x=0, B=X \text{)} \\
X & \to & 1X & \text{(form: } A \to xB \text{, where } x=1, B=X \text{)} \\
X & \to & 1 & \text{(form: } A \to x \text{, where } x=1 \text{)}
\end{array}
$$

Every production is of the form $A \to xB$ or $A \to x$, so $G_2$ is a **right-linear grammar** (and therefore a regular grammar).

**Language generated:**

Starting with $S \Rightarrow 0X$, we observe that $X$ generates any string of 0's and 1's that **ends with 1**, since:
- The only way to terminate is via $X \to 1$
- Before terminating, we can use $X \to 0X$ or $X \to 1X$ any number of times

Therefore:
$$L(G_2) = \{ 0w \mid w \in \{0,1\}^*, \text{ and } w \text{ ends with } 1 \}$$

Equivalently: $L(G_2) = \{ 0u1 \mid u \in \{0,1\}^* \}$ (all binary strings starting with 0 and ending with 1).

**Note:** Since this is a regular grammar, $L(G_2)$ is a regular language, even though it's written as a context-free grammar. This demonstrates that some context-free grammars actually generate regular languages.

