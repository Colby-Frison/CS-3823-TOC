# Context-Free Languages

## Table of Contents
- [Introduction to Context-Free Grammars](#introduction-to-context-free-grammars)
- [Formal Definition of CFG](#formal-definition-of-cfg)
- [Derivations and Parse Trees](#derivations-and-parse-trees)
- [Chomsky Normal Form](#chomsky-normal-form)
- [Ambiguity in Grammars](#ambiguity-in-grammars)
- [Regular vs Context-Free Languages](#regular-vs-context-free-languages)
- [Pumping Lemma for Context-Free Languages](#pumping-lemma-for-context-free-languages)
- [Examples](#examples)

---

## Introduction to Context-Free Grammars

Context-Free Grammars (CFGs) are a more powerful formalism than regular grammars, capable of generating languages that require nested structures and balanced parentheses. They are essential for describing programming language syntax.

**Key characteristics:**
- Production rules have a single nonterminal on the left-hand side
- Right-hand side can contain any combination of terminals and nonterminals
- More powerful than regular grammars but less powerful than context-sensitive grammars

**Applications:**
- Programming language syntax (parsers)
- Natural language processing
- XML/HTML structure
- Mathematical expression parsing

---

## Formal Definition of CFG

A context-free grammar is a 4-tuple:
$$G = (V, \Sigma, R, S)$$

Where:
- **V**: Finite set of variables (nonterminals)
- **Î£**: Finite set of terminals (alphabet)
- **R**: Finite set of production rules of the form $A \to w$ where $A \in V$ and $w \in (V \cup \Sigma)^*$
- **S**: Start variable ($S \in V$)

**Key property:** The left-hand side of every production is a single nonterminal (no context required).

---

## Derivations and Parse Trees

**Derivation:**
A sequence of rule applications that transforms the start symbol into a string of terminals.

**Leftmost derivation:** Always expand the leftmost nonterminal first.

**Rightmost derivation:** Always expand the rightmost nonterminal first.

**Parse tree:** A tree representation of a derivation showing how the grammar generates a string.

**Language generated by $G$:**
$$L(G) = \{w \in \Sigma^* \mid S \Rightarrow^* w\}$$

Where $\Rightarrow^*$ denotes zero or more derivation steps.

---

## Chomsky Normal Form

A context-free grammar is in **Chomsky Normal Form (CNF)** if every production rule has one of two forms:
1. $A \to BC$ (two nonterminals)
2. $A \to a$ (single terminal)

**Theorem:** Every context-free language has a grammar in Chomsky Normal Form.

### Conversion Algorithm (5 Steps):

**Step 1: Add a new start variable**
- If $S$ appears on the right-hand side of any production, add $S_0 \to S$

**Step 2: Eliminate all $\lambda$-rules ($A \to \varepsilon$)**
- For each rule $A \to \varepsilon$, remove it and add rules $B \to \alpha$ for every $B \to \alpha A$ or $B \to A\alpha$
- Repeat until no $\lambda$-rules remain

**Step 3: Eliminate all unit rules ($A \to B$)**
- For each unit rule $A \to B$, if $B \to \alpha$ exists, add $A \to \alpha$
- Remove the unit rule
- Repeat until no unit rules remain

**Step 4: Patch up the grammar**
- Ensure the grammar still generates the same language

**Step 5: Convert remaining rules to CNF form**
- For rules $A \to a_1a_2...a_k$ where $k > 1$:
  - If $a_i$ is a terminal, introduce new nonterminal $T_{a_i} \to a_i$
  - Replace terminals with their nonterminal equivalents
  - Break long sequences into pairs: $A \to BC$ where $B$ and $C$ are nonterminals

---

## Ambiguity in Grammars

**Definition:** A grammar $G$ is **ambiguous** if there exists some string $w \in L(G)$ that has two or more different leftmost derivations (or parse trees).

**Unambiguous grammar:** Every string in $L(G)$ has exactly one leftmost derivation.

**Key points:**
- Ambiguity is a property of the grammar, not the language
- Some languages are inherently ambiguous (every grammar for them is ambiguous)
- For programming languages, ambiguity is problematic (affects parsing)

**Common sources of ambiguity:**
- Operator precedence issues
- Dangling else problem
- Multiple ways to group expressions

---

## Regular vs Context-Free Languages

**Relationship:**
- Every regular language is context-free
- The containment is proper: $\text{Regular Languages} \subset \text{Context-Free Languages}$

**Proof that regular languages are context-free:**
- Every finite automaton can be converted to a regular grammar
- Every regular grammar is a context-free grammar (regular grammars are a subset of CFGs)

**Example of CF but not regular:**
- $\{0^n1^n \mid n \geq 0\}$ is context-free but not regular
- Requires a PDA or CFG to recognize
- Cannot be recognized by a finite automaton (requires unbounded memory)

**Testing if a CFG generates a regular language:**
- If all productions are of the form $A \to xB$ or $A \to x$ (right-linear) or $A \to Bx$ or $A \to x$ (left-linear), then the language is regular

---

## Pumping Lemma for Context-Free Languages

**Purpose:** Used to prove that certain languages are **not** context-free.

### Statement

If $L$ is a context-free language, then there exists a pumping length $p > 0$ such that any string $w \in L$ with $|w| \geq p$ can be decomposed as $w = uvxyz$ where:

1. $|vxy| \leq p$
2. $|vy| \geq 1$
3. For all $i \geq 0$, the string $uv^ixy^iz \in L$

### How to Use (Proof by Contradiction)

1. **Assume** $L$ is context-free
2. **Choose** a string $w \in L$ with $|w| \geq p$ that is "long enough"
3. **Show** that for any decomposition $w = uvxyz$ satisfying conditions 1 and 2, there exists some $i$ such that $uv^ixy^iz \notin L$
4. **Conclude** that $L$ cannot be context-free

### Common Strategy

Choose strings of the form $a^pb^pc^p$ or similar patterns where:
- The pumped substring $vxy$ must be contained in a limited region (by condition 1)
- Pumping will break the required balance or structure
- Consider cases based on where $vxy$ falls in the string

---

## Examples

### Example 1: Analyzing a Context-Free Grammar

**Problem:** Consider the context-free grammar $G_2$:
$$
\begin{array}{rcl}
S & \to & 0X \\
X & \to & 0X \mid 1X \mid 1
\end{array}
$$

**(a) What language does $G_2$ recognize?**

Starting with $S \Rightarrow 0X$, we observe that $X$ generates any string of 0's and 1's that **ends with 1**, since:
- The only way to terminate is via $X \to 1$
- Before terminating, we can use $X \to 0X$ or $X \to 1X$ any number of times

Therefore, $X$ generates $\{0,1\}^*1$, and:
$$L(G_2) = \{ 0w \mid w \in \{0,1\}^*, \text{ and } w \text{ ends with } 1 \}$$

Equivalently: $L(G_2) = \{ 0u1 \mid u \in \{0,1\}^* \}$ (all binary strings starting with 0 and ending with 1).

**(b) Is $L(G_2)$ regular?**

**Yes**, $L(G_2)$ is regular.

**Proof using Regular Grammar Definition:**

Recall that a **regular grammar** is one that is either right-linear or left-linear:
- **Right-linear:** All productions have the form $A \to xB$ or $A \to x$, where $A, B \in V$ (nonterminals) and $x \in T^*$ (string of terminals)
- **Left-linear:** All productions have the form $A \to Bx$ or $A \to x$

Let's examine the productions of $G_2$:
$$
\begin{array}{rcll}
S & \to & 0X & \text{(form: } A \to xB \text{, where } x=0, B=X \text{)} \\
X & \to & 0X & \text{(form: } A \to xB \text{, where } x=0, B=X \text{)} \\
X & \to & 1X & \text{(form: } A \to xB \text{, where } x=1, B=X \text{)} \\
X & \to & 1 & \text{(form: } A \to x \text{, where } x=1 \text{)}
\end{array}
$$

Every production is of the form $A \to xB$ or $A \to x$, so $G_2$ is a **right-linear grammar**.

Since $G_2$ is a regular grammar, it generates a regular language. Therefore, $L(G_2)$ is regular.

**(c) Give a CFG in Chomsky Normal Form generating $L(G_2)$.**

We convert the original grammar to CNF using the standard 5-step procedure:

**Original Grammar:**
$$
\begin{array}{rcl}
S & \to & 0X \\
X & \to & 0X \mid 1X \mid 1
\end{array}
$$

**Step 1: Add a new start variable.**
Not needed here, as $S$ doesn't appear on the right-hand side of any production.

**Step 2: Eliminate all $\lambda$-rules (of the form $A \to \lambda$).**
No $\lambda$-rules exist in this grammar, so no changes needed.

**Step 3: Eliminate all unit rules (of the form $A \to B$).**
No unit rules exist in this grammar, so no changes needed.

**Step 4: Patch up the grammar.**
The grammar still generates the same language $L(G_2) = \{0u1 \mid u \in \{0,1\}^*\}$, so no patching needed.

**Step 5: Convert the remaining rules into proper CNF form.**

CNF requires all productions to be either:
- $A \to BC$ (two nonterminals), or
- $A \to a$ (single terminal)

The problematic rules are $S \to 0X$, $X \to 0X$, and $X \to 1X$ (terminal mixed with nonterminal).

We introduce new nonterminals for each terminal:
- $T_0 \to 0$
- $T_1 \to 1$

Replace terminals in mixed productions:
- $S \to 0X$ becomes $S \to T_0 X$
- $X \to 0X$ becomes $X \to T_0 X$
- $X \to 1X$ becomes $X \to T_1 X$
- $X \to 1$ stays as-is (already in CNF)

**Final CNF Grammar:**
$$
\begin{array}{rcl}
S & \to & T_0 X \\
X & \to & T_0 X \mid T_1 X \mid 1 \\
T_0 & \to & 0 \\
T_1 & \to & 1
\end{array}
$$

All rules are now in proper CNF form.

**(d) Is this CFG ambiguous?**

**No**, the grammar is **not ambiguous**.

**Proof using the Definition of Ambiguity:**

Recall that a grammar $G$ is **ambiguous** if it generates some string $w$ ambiguously, meaning that string has two or more different leftmost derivations.

Conversely, a grammar is **unambiguous** if every string in $L(G)$ has exactly one leftmost derivation.

For our grammar $G_2$, consider any string $w \in L(G_2)$. We know $w$ has the form $w = 0u1$ where $u \in \{0,1\}^*$.

The leftmost derivation of $w$ must proceed as follows:
1. **Start:** $S \Rightarrow 0X$ (this is the only production from $S$, so no choice here)
2. **Middle:** For each symbol $s_i$ in $u = s_1s_2\ldots s_k$:
   - If $s_i = 0$: we must apply $X \Rightarrow 0X$ (uniquely determined by the symbol we need)
   - If $s_i = 1$: we must apply $X \Rightarrow 1X$ (uniquely determined by the symbol we need)
3. **End:** $X \Rightarrow 1$ (this is the only way to terminate and produce the final 1)

Since each derivation step is uniquely determined by the target string, every string in $L(G_2)$ has **exactly one leftmost derivation**.

Therefore, by definition, the grammar $G_2$ is **unambiguous**.

---

### Example 2: Using the Pumping Lemma for CFLs

**Problem:** Let $\Sigma = \{0, 1, 2, 3\}$. Is the language 
$$L_1 = \{w \in \Sigma^* \mid \text{in } w, \text{ the number of } 0\text{'s equals the number of } 1\text{'s, and the number of } 2\text{'s equals the number of } 3\text{'s}\}$$
context-free? Show your answer is correct.

**Solution:**

The language
$$L_1 = \{ w \in \{0,1,2,3\}^* \mid \#_0(w) = \#_1(w) \text{ and } \#_2(w) = \#_3(w) \}$$
is **not** context-free. We prove this by contradiction using the pumping lemma for context-free languages.

**Assumption:** Assume, for contradiction, that $L_1$ is context-free. Then by the pumping lemma for context-free languages, there exists a pumping length $p > 0$ such that any string $w \in L_1$ with $|w| \geq p$ can be decomposed as $w = uvxyz$ where:
1. $|vxy| \leq p$
2. $|vy| \geq 1$
3. For all $i \geq 0$, the string $uv^ixy^iz \in L_1$

**Choose the string:** Consider the string $w = 0^p 2^p 1^p 3^p$ which clearly lies in $L_1$ since it has exactly $p$ zeros, $p$ ones, $p$ twos, and $p$ threes, satisfying both conditions $\#_0(w) = \#_1(w)$ and $\#_2(w) = \#_3(w)$.

**Analysis:** By the pumping lemma, we can write $w = uvxyz$ with $|vxy| \leq p$ and $|vy| \geq 1$. 

Since $|vxy| \leq p$, the substring $vxy$ must be contained entirely within one of the four uniform blocks $0^p, 2^p, 1^p, 3^p$, or it must straddle exactly one adjacent boundary between these blocks.

We now show that in every possible case, pumping leads to a contradiction:

**Case 1:** If $vxy$ is contained within a single block, then $v$ and $y$ contain only one type of symbol (all $0$s, all $2$s, all $1$s, or all $3$s). Pumping up (setting $i = 2$) or pumping down (setting $i = 0$) changes that symbol's count while leaving at least one of its required partner counts untouched. For example, if $vxy$ is contained in the $0^p$ block, then pumping increases or decreases the number of $0$s without changing the number of $1$s, breaking the requirement $\#_0 = \#_1$. Similar contradictions occur for the other blocks.

**Case 2:** If $vxy$ straddles the boundary between two blocks (say the $0/2$ boundary), then pumping alters both symbols in the boundary but still leaves the symbols farther to the right unchanged. For instance, pumping across the $0/2$ boundary changes the number of $0$s without changing the number of $1$s, breaking the requirement $\#_0 = \#_1$. Similar contradictions occur for the $2/1$ and $1/3$ boundaries.

**Contradiction:** In all cases, no decomposition $uvxyz$ can satisfy the pumping lemma conditions while maintaining membership in $L_1$. This contradicts our assumption that $L_1$ is context-free. Therefore, $L_1$ is **not** a context-free language.

